"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateOverlay = exports.brushEnd = exports.brushing = exports.brushStart = exports.doubleclickVoronoi = exports.clickVoronoi = exports.changeVoronoi = void 0;

var React = _interopRequireWildcard(require("react"));

var _coordinateNames = require("../constants/coordinateNames");

var _d3Array = require("d3-array");

var _d3Voronoi = require("d3-voronoi");

var _semioticMark = require("semiotic-mark");

var _this = void 0;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var constructDataObject = function constructDataObject(d, points) {
  if (d === undefined) return d;
  return d && d.data ? _objectSpread({
    points: points
  }, d.data, d) : _objectSpread({
    points: points
  }, d);
};

var changeVoronoi = function changeVoronoi(voronoiHover, d, customHoverTypes, customHoverBehavior, points) {
  //Until semiotic 2
  var dataObject = constructDataObject(d, points);
  if (customHoverBehavior) customHoverBehavior(dataObject);
  if (!d) voronoiHover(null);else if (customHoverTypes === true) {
    var vorD = _extends({}, dataObject);

    vorD.type = vorD.type === "column-hover" ? "column-hover" : "frame-hover";
    voronoiHover(vorD);
  } else if (customHoverTypes) {
    var arrayWrappedHoverTypes = Array.isArray(customHoverTypes) ? customHoverTypes : [customHoverTypes];
    var mappedHoverTypes = arrayWrappedHoverTypes.map(function (c) {
      var finalC = typeof c === "function" ? c(dataObject) : c;
      if (!finalC) return undefined;
      return _extends({}, dataObject, finalC);
    }).filter(function (d) {
      return d;
    });
    voronoiHover(mappedHoverTypes);
  }
};

exports.changeVoronoi = changeVoronoi;

var clickVoronoi = function clickVoronoi(d, customClickBehavior, points) {
  //Until semiotic 2
  var dataObject = constructDataObject(d, points);
  if (customClickBehavior) customClickBehavior(dataObject);
};

exports.clickVoronoi = clickVoronoi;

var doubleclickVoronoi = function doubleclickVoronoi(d, customDoubleClickBehavior, points) {
  //Until semiotic 2
  var dataObject = constructDataObject(d, points);
  if (customDoubleClickBehavior) customDoubleClickBehavior(dataObject);
};

exports.doubleclickVoronoi = doubleclickVoronoi;

var brushStart = function brushStart(e, columnName, data, columnData, interaction) {
  if (interaction && interaction.start) interaction.start(e, columnName, data, columnData);
};

exports.brushStart = brushStart;

var brushing = function brushing(e, columnName, data, columnData, interaction) {
  if (interaction && interaction.during) interaction.during(e, columnName, data, columnData);
};

exports.brushing = brushing;

var brushEnd = function brushEnd(e, columnName, data, columnData, interaction) {
  if (interaction && interaction.end) interaction.end(e, columnName, data, columnData);
};

exports.brushEnd = brushEnd;

var calculateOverlay = function calculateOverlay(props) {
  var voronoiPaths = [];
  var xScale = props.xScale,
      yScale = props.yScale,
      points = props.points,
      projectedX = props.projectedX,
      showLinePoints = props.showLinePoints,
      size = props.size,
      overlay = props.overlay,
      _props$interactionOve = props.interactionOverflow,
      interactionOverflow = _props$interactionOve === void 0 ? {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  } : _props$interactionOve,
      customClickBehavior = props.customClickBehavior,
      customDoubleClickBehavior = props.customDoubleClickBehavior,
      customHoverBehavior = props.customHoverBehavior,
      hoverAnnotation = props.hoverAnnotation,
      voronoiHover = props.voronoiHover,
      margin = props.margin;
  var whichPoints = {
    top: _coordinateNames.projectedYTop,
    bottom: _coordinateNames.projectedYBottom
  };
  var pointerStyle = customClickBehavior || customDoubleClickBehavior ? {
    cursor: "pointer"
  } : {};

  if (points && hoverAnnotation && !overlay) {
    var voronoiDataset = [];
    var voronoiUniqueHash = {};
    points.forEach(function (d) {
      var xValue = Math.floor(xScale(d[projectedX]));
      var yValue = Math.floor(yScale(showLinePoints && d[whichPoints[showLinePoints]] !== undefined ? d[whichPoints[showLinePoints]] : d[_coordinateNames.projectedYMiddle] !== undefined ? d[_coordinateNames.projectedYMiddle] : d[_coordinateNames.projectedY]));

      if (xValue >= 0 - margin.left && xValue <= size[0] + margin.right && yValue >= 0 - margin.top && yValue <= size[1] + margin.bottom && xValue !== undefined && yValue !== undefined && isNaN(xValue) === false && isNaN(yValue) === false) {
        var pointKey = "".concat(xValue, ",").concat(yValue);

        if (!voronoiUniqueHash[pointKey]) {
          var voronoiPoint = _objectSpread({}, d, {
            coincidentPoints: [d],
            voronoiX: xValue,
            voronoiY: yValue
          });

          voronoiDataset.push(voronoiPoint);
          voronoiUniqueHash[pointKey] = voronoiPoint;
        } else voronoiUniqueHash[pointKey].coincidentPoints.push(d);
      }
    });
    var voronoiXExtent = (0, _d3Array.extent)(voronoiDataset.map(function (d) {
      return d.voronoiX;
    }));
    var voronoiYExtent = (0, _d3Array.extent)(voronoiDataset.map(function (d) {
      return d.voronoiY;
    }));
    var voronoiExtent = [[Math.min(voronoiXExtent[0] - 5, -interactionOverflow.left), Math.min(voronoiYExtent[0] - 5, -interactionOverflow.top)], [Math.max(voronoiXExtent[1] + 5, size[0] + interactionOverflow.right), Math.max(voronoiYExtent[1] + 5, size[1] + interactionOverflow.bottom)]];
    var voronoiDiagram = (0, _d3Voronoi.voronoi)().extent(voronoiExtent).x(function (d) {
      return d.voronoiX;
    }).y(function (d) {
      return d.voronoiY;
    });
    var voronoiData = voronoiDiagram.polygons(voronoiDataset);
    voronoiPaths = voronoiData.map(function (d, i) {
      return React.createElement("path", {
        onClick: function onClick() {
          clickVoronoi(voronoiDataset[i], customClickBehavior, points);
        },
        onDoubleClick: function onDoubleClick() {
          doubleclickVoronoi(voronoiDataset[i], customDoubleClickBehavior, points);
        },
        onMouseEnter: function onMouseEnter() {
          changeVoronoi(voronoiHover, voronoiDataset[i], hoverAnnotation, customHoverBehavior, points);
        },
        onMouseLeave: function onMouseLeave() {
          changeVoronoi(voronoiHover, undefined, undefined, customHoverBehavior);
        },
        key: "interactionVoronoi".concat(i),
        d: "M".concat(d.join("L"), "Z"),
        style: _objectSpread({
          fillOpacity: 0
        }, pointerStyle)
      });
    }, _this);
    return voronoiPaths;
  } else if (overlay) {
    var renderedOverlay = overlay.map(function (overlayRegion, i) {
      var overlayData = overlayRegion.overlayData,
          rest = _objectWithoutProperties(overlayRegion, ["overlayData"]);

      var overlayProps = {
        key: "overlay-".concat(i),
        onMouseEnter: function onMouseEnter() {
          changeVoronoi(voronoiHover, overlayData, props.hoverAnnotation, customHoverBehavior, points);
        },
        onMouseLeave: function onMouseLeave() {
          changeVoronoi(voronoiHover, undefined, undefined, customHoverBehavior);
        },
        onClick: function onClick() {
          clickVoronoi(overlayData, customClickBehavior, points);
        },
        onDoubleClick: function onDoubleClick() {
          doubleclickVoronoi(overlayData, customDoubleClickBehavior, points);
        },
        style: _objectSpread({
          opacity: 0
        }, pointerStyle)
      };

      if (React.isValidElement(overlayRegion.renderElement)) {
        return React.cloneElement(overlayRegion.renderElement, overlayProps);
      } else {
        return React.createElement(_semioticMark.Mark, _extends({
          forceUpdate: true
        }, rest, {
          key: "overlay-".concat(i)
        }, overlayProps));
      }
    });
    return renderedOverlay;
  }
};

exports.calculateOverlay = calculateOverlay;