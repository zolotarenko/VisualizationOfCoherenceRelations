"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateXYFrame = void 0;

var React = _interopRequireWildcard(require("react"));

var _d3Scale = require("d3-scale");

var _Axis = _interopRequireDefault(require("../Axis"));

var _axis = require("../visualizationLayerBehavior/axis");

var _dataFunctions = require("../data/dataFunctions");

var _AnnotationCallout = _interopRequireDefault(require("react-annotation/lib/Types/AnnotationCallout"));

var _general = require("../visualizationLayerBehavior/general");

var _frameFunctions = require("../svg/frameFunctions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var screenScales = function screenScales(_ref) {
  var xExtent = _ref.xExtent,
      yExtent = _ref.yExtent,
      adjustedSize = _ref.adjustedSize,
      xScaleType = _ref.xScaleType,
      yScaleType = _ref.yScaleType;
  var xDomain = [0, adjustedSize[0]];
  var yDomain = [adjustedSize[1], 0];
  var xScale = xScaleType;
  var yScale = yScaleType;

  if (xScaleType.domain) {
    xScaleType.domain(xExtent);
  }

  if (yScaleType.domain) {
    yScaleType.domain(yExtent);
  }

  xScaleType.range(xDomain);
  yScaleType.range(yDomain);
  return {
    xScale: xScale,
    yScale: yScale
  };
};

var naturalLanguageLineType = {
  line: {
    items: "line",
    chart: "line chart"
  },
  area: {
    items: "summary",
    chart: "summary chart"
  },
  summary: {
    items: "summary",
    chart: "summary chart"
  },
  cumulative: {
    items: "line",
    chart: "cumulative chart"
  },
  "cumulative-reverse": {
    items: "line",
    chart: "cumulative chart"
  },
  linepercent: {
    items: "line",
    chart: "line chart"
  },
  stackedarea: {
    items: "stacked area",
    chart: "stacked area chart"
  },
  "stackedarea-invert": {
    items: "stacked area",
    chart: "stacked area chart"
  },
  stackedpercent: {
    items: "stacked area",
    chart: "stacked area chart"
  },
  "stackedpercent-invert": {
    items: "stacked area",
    chart: "stacked area chart"
  },
  bumparea: {
    items: "ranked area",
    chart: "ranked area chart"
  },
  "bumparea-invert": {
    items: "ranked area",
    chart: "ranked area chart"
  },
  bumpline: {
    items: "ranked line",
    chart: "ranked line chart"
  },
  difference: {
    items: "line",
    chart: "difference chart"
  }
};

var emptyObjectReturnFunction = function emptyObjectReturnFunction() {
  return {};
};

var emptyStringReturnFunction = function emptyStringReturnFunction() {
  return "";
};

var calculateXYFrame = function calculateXYFrame(currentProps, prevState, updateData) {
  var legend = currentProps.legend,
      lines = currentProps.lines,
      lineClass = currentProps.lineClass,
      pointStyle = currentProps.pointStyle,
      pointRenderMode = currentProps.pointRenderMode,
      pointClass = currentProps.pointClass,
      summaryClass = currentProps.summaryClass,
      canvasLines = currentProps.canvasLines,
      canvasPoints = currentProps.canvasPoints,
      canvasSummaries = currentProps.canvasSummaries,
      defined = currentProps.defined,
      size = currentProps.size,
      renderKey = currentProps.renderKey,
      lineType = currentProps.lineType,
      summaryType = currentProps.summaryType,
      customLineMark = currentProps.customLineMark,
      customPointMark = currentProps.customPointMark,
      customSummaryMark = currentProps.customSummaryMark,
      summaryStyle = currentProps.summaryStyle,
      summaryRenderMode = currentProps.summaryRenderMode,
      lineStyle = currentProps.lineStyle,
      lineRenderMode = currentProps.lineRenderMode,
      baseXExtent = currentProps.xExtent,
      baseYExtent = currentProps.yExtent,
      title = currentProps.title,
      _currentProps$xScaleT = currentProps.xScaleType,
      baseXScaleType = _currentProps$xScaleT === void 0 ? (0, _d3Scale.scaleLinear)() : _currentProps$xScaleT,
      _currentProps$yScaleT = currentProps.yScaleType,
      baseYScaleType = _currentProps$yScaleT === void 0 ? (0, _d3Scale.scaleLinear)() : _currentProps$yScaleT,
      lineIDAccessor = currentProps.lineIDAccessor,
      invertX = currentProps.invertX,
      invertY = currentProps.invertY,
      showLinePoints = currentProps.showLinePoints,
      showSummaryPoints = currentProps.showSummaryPoints,
      points = currentProps.points,
      lineDataAccessor = currentProps.lineDataAccessor,
      summaryDataAccessor = currentProps.summaryDataAccessor,
      yAccessor = currentProps.yAccessor,
      xAccessor = currentProps.xAccessor,
      useSummariesAsInteractionLayer = currentProps.useSummariesAsInteractionLayer,
      baseMarkProps = currentProps.baseMarkProps,
      filterRenderedLines = currentProps.filterRenderedLines,
      filterRenderedSummaries = currentProps.filterRenderedSummaries,
      filterRenderedPoints = currentProps.filterRenderedPoints,
      annotations = currentProps.annotations;
  var projectedLines = currentProps.projectedLines,
      projectedPoints = currentProps.projectedPoints,
      projectedSummaries = currentProps.projectedSummaries,
      summaries = currentProps.summaries,
      fullDataset = currentProps.fullDataset;

  if (summaryType && points && !summaries) {
    summaries = [{
      coordinates: points
    }];
  }

  var castXScaleType = baseXScaleType;
  var xScaleType = baseXScaleType.domain ? baseXScaleType : castXScaleType();
  var castYScaleType = baseYScaleType;
  var yScaleType = baseYScaleType.domain ? baseYScaleType : castYScaleType();
  var annotatedSettings = {
    xAccessor: (0, _dataFunctions.stringToArrayFn)(xAccessor, function (d) {
      return d[0];
    }),
    yAccessor: (0, _dataFunctions.stringToArrayFn)(yAccessor, function (d) {
      return d[1];
    }),
    summaryDataAccessor: (0, _dataFunctions.stringToArrayFn)(summaryDataAccessor, function (d) {
      return Array.isArray(d) ? d : d.coordinates;
    }),
    lineDataAccessor: (0, _dataFunctions.stringToArrayFn)(lineDataAccessor, function (d) {
      return Array.isArray(d) ? d : d.coordinates;
    }),
    renderKeyFn: (0, _dataFunctions.stringToFn)(renderKey, function (d, i) {
      return "line-".concat(i);
    }, true),
    lineType: (0, _frameFunctions.objectifyType)(lineType),
    summaryType: (0, _frameFunctions.objectifyType)(summaryType),
    lineIDAccessor: (0, _dataFunctions.stringToFn)(lineIDAccessor, function (l) {
      return l.semioticLineID;
    }),
    summaries: !summaries || Array.isArray(summaries) && summaries.length === 0 ? undefined : !Array.isArray(summaries) ? [summaries] : !summaryDataAccessor && !summaries[0].coordinates ? [{
      coordinates: summaries
    }] : summaries,
    lines: !lines || Array.isArray(lines) && lines.length === 0 ? undefined : !Array.isArray(lines) ? [lines] : !lineDataAccessor && !lines[0].coordinates ? [{
      coordinates: lines
    }] : lines,
    title: _typeof(title) === "object" && !React.isValidElement(title) && title !== null ? title : {
      title: title,
      orient: "top"
    },
    xExtent: Array.isArray(baseXExtent) ? baseXExtent : !baseXExtent ? undefined : baseXExtent.extent,
    yExtent: Array.isArray(baseYExtent) ? baseYExtent : !baseYExtent ? undefined : baseYExtent.extent
  };

  if (annotatedSettings.lineType.type === "area") {
    annotatedSettings.lineType.y1 = function () {
      return 0;
    };

    annotatedSettings.lineType.simpleLine = false;
  }

  var summaryStyleFn = (0, _dataFunctions.stringToFn)(summaryStyle, emptyObjectReturnFunction, true);
  var summaryClassFn = (0, _dataFunctions.stringToFn)(summaryClass, emptyStringReturnFunction, true);
  var summaryRenderModeFn = (0, _dataFunctions.stringToFn)(summaryRenderMode, undefined, true);
  var generatedAxes = currentProps.axes && currentProps.axes.map(function (axisFnOrObject) {
    return typeof axisFnOrObject === "function" ? axisFnOrObject({
      size: currentProps.size
    }) : axisFnOrObject;
  });
  var margin = (0, _frameFunctions.calculateMargin)({
    margin: currentProps.margin,
    axes: generatedAxes,
    title: annotatedSettings.title,
    size: currentProps.size
  });

  var _adjustedPositionSize = (0, _frameFunctions.adjustedPositionSize)({
    size: currentProps.size,
    margin: margin
  }),
      adjustedPosition = _adjustedPositionSize.adjustedPosition,
      adjustedSize = _adjustedPositionSize.adjustedSize;

  var calculatedXExtent = [],
      calculatedYExtent = [],
      yExtent,
      xExtent,
      xExtentSettings,
      yExtentSettings;

  if (_typeof(baseXExtent) === "object") {
    xExtentSettings = baseXExtent;
  } else {
    xExtentSettings = {
      extent: baseXExtent
    };
  }

  if (_typeof(baseYExtent) === "object") {
    yExtentSettings = baseYExtent;
  } else {
    yExtentSettings = {
      extent: baseYExtent
    };
  }

  var xScale, yScale;

  if (updateData || currentProps.dataVersion && currentProps.dataVersion !== prevState.dataVersion) {
    //This will always fire at this point because xExtent/yExtent are just defined up there so revisit this logic
    if (!xExtent || !yExtent || !fullDataset || !projectedLines && !projectedPoints && !projectedSummaries) {
      ;

      var _calculateDataExtent = (0, _dataFunctions.calculateDataExtent)({
        lineDataAccessor: annotatedSettings.lineDataAccessor,
        summaryDataAccessor: annotatedSettings.summaryDataAccessor,
        xAccessor: annotatedSettings.xAccessor,
        yAccessor: annotatedSettings.yAccessor,
        lineType: annotatedSettings.lineType,
        summaryType: annotatedSettings.summaryType,
        summaries: annotatedSettings.summaries,
        points: points,
        lines: annotatedSettings.lines,
        showLinePoints: showLinePoints,
        showSummaryPoints: showSummaryPoints,
        xExtent: baseXExtent,
        yExtent: baseYExtent,
        invertX: invertX,
        invertY: invertY,
        adjustedSize: adjustedSize,
        margin: margin,
        baseMarkProps: baseMarkProps,
        summaryStyleFn: summaryStyleFn,
        summaryClassFn: summaryClassFn,
        summaryRenderModeFn: summaryRenderModeFn,
        chartSize: size,
        xScaleType: xScaleType,
        yScaleType: yScaleType,
        defined: defined,
        filterRenderedLines: filterRenderedLines,
        filterRenderedSummaries: filterRenderedSummaries,
        filterRenderedPoints: filterRenderedPoints,
        annotations: annotations
      });

      xExtent = _calculateDataExtent.xExtent;
      yExtent = _calculateDataExtent.yExtent;
      projectedLines = _calculateDataExtent.projectedLines;
      projectedPoints = _calculateDataExtent.projectedPoints;
      projectedSummaries = _calculateDataExtent.projectedSummaries;
      fullDataset = _calculateDataExtent.fullDataset;
      calculatedXExtent = _calculateDataExtent.calculatedXExtent;
      calculatedYExtent = _calculateDataExtent.calculatedYExtent;
    }

    ;

    var _screenScales = screenScales({
      xExtent: xExtent,
      yExtent: yExtent,
      adjustedSize: adjustedSize,
      xScaleType: xScaleType.copy(),
      yScaleType: yScaleType.copy()
    });

    xScale = _screenScales.xScale;
    yScale = _screenScales.yScale;
  } else {
    ;
    xExtent = prevState.xExtent;
    yExtent = prevState.yExtent;
    projectedLines = prevState.projectedLines;
    projectedPoints = prevState.projectedPoints;
    projectedSummaries = prevState.projectedSummaries;
    fullDataset = prevState.fullDataset;
    calculatedXExtent = prevState.calculatedXExtent;
    calculatedYExtent = prevState.calculatedYExtent;

    if (adjustedSize[0] === prevState.adjustedSize[0] && adjustedSize[1] === prevState.adjustedSize[1]) {
      xScale = prevState.xScale;
      yScale = prevState.yScale;
    } else {
      ;

      var _screenScales2 = screenScales({
        xExtent: xExtent,
        yExtent: yExtent,
        adjustedSize: adjustedSize,
        xScaleType: xScaleType,
        yScaleType: yScaleType
      });

      xScale = _screenScales2.xScale;
      yScale = _screenScales2.yScale;
    }
  }

  xExtent = Array.isArray(xExtentSettings.extent) && xExtentSettings.extent.length === 2 ? xExtentSettings.extent : xExtent;
  yExtent = Array.isArray(yExtentSettings.extent) && yExtentSettings.extent.length === 2 ? yExtentSettings.extent : yExtent;
  var canvasDrawing = [];
  var axes;
  var axesTickLines;
  var existingBaselines = {};

  if (generatedAxes) {
    axesTickLines = [];
    axes = generatedAxes.map(function (d, i) {
      var axisClassname = d.className || "";
      axisClassname += " axis";
      var axisScale = yScale;

      if (existingBaselines[d.orient]) {
        d.baseline = d.baseline || false;
      }

      existingBaselines[d.orient] = true;

      if (d.orient === "top" || d.orient === "bottom") {
        axisClassname += " x";
        axisScale = xScale;
      } else {
        axisClassname += " y";
      }

      axisClassname += " ".concat(d.orient);
      var tickValues;

      if (d.tickValues && Array.isArray(d.tickValues)) {
        tickValues = d.tickValues;
      } else if (d.tickValues instanceof Function) {
        //otherwise assume a function
        tickValues = d.tickValues(fullDataset, currentProps.size, axisScale);
      }

      var axisSize = [adjustedSize[0], adjustedSize[1]];
      var axisParts = (0, _axis.axisPieces)({
        padding: d.padding,
        tickValues: tickValues,
        scale: axisScale,
        ticks: d.ticks,
        orient: d.orient,
        size: axisSize,
        footer: d.footer,
        tickSize: d.tickSize,
        jaggedBase: d.jaggedBase
      });
      var axisTickLines = React.createElement("g", {
        key: "axes-tick-lines-".concat(i),
        className: "axis ".concat(axisClassname)
      }, (0, _axis.axisLines)({
        axisParts: axisParts,
        orient: d.orient,
        tickLineGenerator: d.tickLineGenerator,
        baseMarkProps: baseMarkProps,
        className: axisClassname,
        jaggedBase: d.jaggedBase,
        scale: axisScale
      }), d.baseline === "under" && (0, _axis.baselineGenerator)(d.orient, adjustedSize, d.className));
      axesTickLines.push(axisTickLines);
      return React.createElement(_Axis.default, _extends({}, d, {
        key: d.key || "axis-".concat(i),
        annotationFunction: d.axisAnnotationFunction,
        axisParts: axisParts,
        size: axisSize,
        margin: margin,
        tickValues: tickValues,
        scale: axisScale,
        className: axisClassname,
        xyPoints: fullDataset
      }));
    });
  }

  var legendSettings;

  if (legend) {
    legendSettings = legend === true ? {} : legend;

    if (projectedLines && !legendSettings.legendGroups) {
      var typeString = annotatedSettings.lineType.type;
      var type = typeof typeString === "string" && ["stackedarea", "stackedpercent", "bumparea"].indexOf(typeString) === -1 ? "line" : "fill";
      var legendGroups = [{
        styleFn: currentProps.lineStyle,
        type: type,
        items: projectedLines.map(function (d) {
          return _extends({
            label: annotatedSettings.lineIDAccessor(d)
          }, d);
        })
      }];
      legendSettings.legendGroups = legendGroups;
    }
  }

  var areaAnnotations = [];

  if (annotatedSettings.summaryType.label && projectedSummaries) {
    projectedSummaries.forEach(function (d, i) {
      if (d.bounds) {
        var bounds = Array.isArray(d.bounds) ? d.bounds : [d.bounds];
        bounds.forEach(function (labelBounds) {
          var label = typeof annotatedSettings.summaryType.label === "function" ? annotatedSettings.summaryType.label(d) : annotatedSettings.summaryType.label;

          if (label && label !== null) {
            var labelPosition = label.position || "center";
            var labelCenter = [xScale(labelBounds[labelPosition][0]), yScale(labelBounds[labelPosition][1])] || [xScale(d._xyfCoordinates[0]), yScale(d._xyfCoordinates[1])];

            var labelContent = label.content || function (p) {
              return p.value || p.id || i;
            };

            areaAnnotations.push({
              x: labelCenter[0],
              y: labelCenter[1],
              dx: label.dx,
              dy: label.dy,
              className: label.className,
              type: label.type || _AnnotationCallout.default,
              note: label.note || {
                title: labelContent(d)
              },
              subject: label.subject || {
                text: labelContent(d)
              },
              connector: label.connector
            });
          }
        });
      }
    });
  }

  var lineAriaLabel = annotatedSettings.lineType.type !== undefined && typeof annotatedSettings.lineType.type === "string" && naturalLanguageLineType[annotatedSettings.lineType.type];
  var xyFrameRender = {
    lines: {
      accessibleTransform: function accessibleTransform(data, i) {
        return _objectSpread({}, data[i].data[data[i].data.length - 1], {
          type: "frame-hover"
        });
      },
      data: projectedLines,
      styleFn: (0, _dataFunctions.stringToFn)(lineStyle, emptyObjectReturnFunction, true),
      classFn: (0, _dataFunctions.stringToFn)(lineClass, emptyStringReturnFunction, true),
      renderMode: (0, _dataFunctions.stringToFn)(lineRenderMode, undefined, true),
      canvasRender: (0, _dataFunctions.stringToFn)(canvasLines, undefined, true),
      customMark: customLineMark,
      type: annotatedSettings.lineType,
      defined: defined,
      renderKeyFn: annotatedSettings.renderKeyFn,
      ariaLabel: lineAriaLabel,
      axesData: generatedAxes,
      behavior: _general.createLines
    },
    summaries: {
      accessibleTransform: function accessibleTransform(data, i) {
        return _objectSpread({}, data[i], {
          type: "frame-hover"
        });
      },
      data: projectedSummaries,
      styleFn: summaryStyleFn,
      classFn: summaryClassFn,
      renderMode: summaryRenderModeFn,
      canvasRender: (0, _dataFunctions.stringToFn)(canvasSummaries, undefined, true),
      customMark: customSummaryMark,
      type: annotatedSettings.summaryType,
      renderKeyFn: annotatedSettings.renderKeyFn,
      behavior: _general.createSummaries
    },
    points: {
      accessibleTransform: function accessibleTransform(data, i) {
        return _objectSpread({
          type: "frame-hover"
        }, data[i].data || data[i]);
      },
      data: projectedPoints,
      styleFn: (0, _dataFunctions.stringToFn)(pointStyle, emptyObjectReturnFunction, true),
      classFn: (0, _dataFunctions.stringToFn)(pointClass, emptyStringReturnFunction, true),
      renderMode: (0, _dataFunctions.stringToFn)(pointRenderMode, undefined, true),
      canvasRender: (0, _dataFunctions.stringToFn)(canvasPoints, undefined, true),
      customMark: customPointMark,
      renderKeyFn: annotatedSettings.renderKeyFn,
      showLinePoints: showLinePoints,
      behavior: _general.createPoints
    }
  };

  if (xExtentSettings.onChange && prevState.calculatedXExtent.join(",") !== calculatedXExtent.join(",")) {
    xExtentSettings.onChange(calculatedXExtent);
  }

  if (yExtentSettings.onChange && prevState.calculatedYExtent.join(",") !== calculatedYExtent.join(",")) {
    yExtentSettings.onChange(calculatedYExtent);
  }

  var overlay = undefined;

  if (useSummariesAsInteractionLayer && projectedSummaries) {
    overlay = (0, _general.createSummaries)({
      xScale: xScale,
      yScale: yScale,
      data: projectedSummaries
    }).map(function (m, i) {
      return _objectSpread({}, m.props, {
        style: {
          fillOpacity: 0
        },
        overlayData: projectedSummaries && projectedSummaries[i] // luckily createSummaries is a map fn

      });
    });
  }

  return {
    lineData: currentProps.lines,
    pointData: currentProps.points,
    summaryData: currentProps.summaries,
    dataVersion: currentProps.dataVersion,
    projectedLines: projectedLines,
    projectedPoints: projectedPoints,
    projectedSummaries: projectedSummaries,
    canvasDrawing: canvasDrawing,
    fullDataset: fullDataset,
    adjustedPosition: adjustedPosition,
    adjustedSize: adjustedSize,
    backgroundGraphics: currentProps.backgroundGraphics,
    foregroundGraphics: currentProps.foregroundGraphics,
    axesData: generatedAxes,
    axes: axes,
    axesTickLines: axesTickLines,
    renderNumber: prevState.renderNumber + 1,
    xScale: xScale,
    yScale: yScale,
    xAccessor: annotatedSettings.xAccessor,
    yAccessor: annotatedSettings.yAccessor,
    xExtent: [xExtent[0] === undefined ? calculatedXExtent[0] : xExtent[0], xExtent[1] === undefined ? calculatedXExtent[1] : xExtent[1]],
    yExtent: [yExtent[0] === undefined ? calculatedYExtent[0] : yExtent[0], yExtent[1] === undefined ? calculatedYExtent[1] : yExtent[1]],
    calculatedXExtent: calculatedXExtent,
    calculatedYExtent: calculatedYExtent,
    margin: margin,
    legendSettings: legendSettings,
    areaAnnotations: areaAnnotations,
    xyFrameRender: xyFrameRender,
    size: size,
    annotatedSettings: annotatedSettings,
    overlay: overlay,
    props: currentProps
  };
};

exports.calculateXYFrame = calculateXYFrame;